<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GestureBoard ‚Äî Hand-Controlled Whiteboard</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=Syne+Mono&family=Syne:wght@400;700;800&display=swap');

    *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}

    :root {
      --bg:       #05050a;
      --surf:     #0d0d18;
      --surf2:    #14142a;
      --border:   rgba(255,255,255,0.07);
      --cyan:     #00f5d4;
      --magenta:  #f72585;
      --yellow:   #ffd60a;
      --purple:   #7b2fff;
      --text:     #e8e8f0;
      --muted:    #55556a;
      --mono:     'Syne Mono', monospace;
      --sans:     'Space Grotesk', sans-serif;
      --display:  'Syne', sans-serif;

      --cyan-glow: 0 0 20px rgba(0,245,212,0.35);
      --mag-glow:  0 0 20px rgba(247,37,133,0.35);
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: var(--sans);
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      user-select: none;
    }

    /* ‚îÄ‚îÄ‚îÄ CANVAS LAYER ‚îÄ‚îÄ‚îÄ */
    #mainCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      cursor: none;
      z-index: 1;
    }

    /* ‚îÄ‚îÄ‚îÄ CAMERA PANEL ‚îÄ‚îÄ‚îÄ */
    #camWrap {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 20;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
      box-shadow: var(--cyan-glow), 0 8px 40px rgba(0,0,0,0.6);
      transition: all 0.3s ease;
      background: #000;
    }
    #camWrap:hover { opacity: 0.25; }
    #camWrap video { display: block; width: 220px; height: 165px; object-fit: cover; transform: scaleX(-1); }
    #camCanvas { position: absolute; top: 0; left: 0; width: 220px; height: 165px; transform: scaleX(-1); pointer-events: none; }
    .cam-badge {
      position: absolute; top: 8px; left: 10px;
      font-family: var(--mono); font-size: 8px; letter-spacing: 2px;
      color: var(--cyan); text-transform: uppercase; display: flex; align-items: center; gap: 6px;
    }
    .cam-badge::before {
      content: '';
      width: 5px; height: 5px; border-radius: 50%;
      background: var(--cyan);
      animation: livepulse 1.4s ease-in-out infinite;
      box-shadow: 0 0 8px var(--cyan);
    }
    @keyframes livepulse {
      0%,100%{opacity:1;transform:scale(1)}
      50%{opacity:0.4;transform:scale(0.6)}
    }

    /* ‚îÄ‚îÄ‚îÄ HUD LEFT ‚îÄ‚îÄ‚îÄ */
    #hudLeft {
      position: fixed; top: 20px; left: 20px;
      z-index: 20; pointer-events: none;
      display: flex; flex-direction: column; gap: 12px;
    }
    .hud-brand {
      font-family: var(--display);
      font-size: 26px; font-weight: 800;
      letter-spacing: 0.12em;
      color: var(--cyan);
      text-shadow: 0 0 30px rgba(0,245,212,0.5);
      line-height: 1;
    }
    .hud-brand span { color: var(--muted); font-weight: 400; }

    .hud-card {
      background: rgba(5,5,10,0.82);
      border: 1px solid var(--border);
      border-left: 2px solid var(--cyan);
      backdrop-filter: blur(12px);
      padding: 12px 16px;
      border-radius: 6px;
      min-width: 200px;
    }
    .hud-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 3px 0;
      gap: 12px;
    }
    .hud-k {
      font-family: var(--mono);
      font-size: 9px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--muted);
    }
    .hud-v {
      font-family: var(--mono);
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 1px;
      color: var(--text);
    }
    .hud-v.c-cyan    { color: var(--cyan); }
    .hud-v.c-yellow  { color: var(--yellow); }
    .hud-v.c-magenta { color: var(--magenta); }
    .hud-v.c-purple  { color: #aa88ff; }

    /* mode badge */
    #modeBadge {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 4px 10px 4px 8px;
      background: rgba(0,245,212,0.08);
      border: 1px solid rgba(0,245,212,0.2);
      border-radius: 20px;
      font-family: var(--mono); font-size: 9px; letter-spacing: 2px;
      color: var(--cyan); text-transform: uppercase;
      transition: all 0.25s;
    }
    #modeBadge::before {
      content: '';
      width: 6px; height: 6px; border-radius: 50%;
      background: var(--cyan);
      box-shadow: 0 0 8px var(--cyan);
    }
    #modeBadge.mode-draw  { color: var(--yellow); border-color: rgba(255,214,10,0.3); background: rgba(255,214,10,0.06); }
    #modeBadge.mode-draw::before { background: var(--yellow); box-shadow: 0 0 8px var(--yellow); }
    #modeBadge.mode-erase { color: var(--magenta); border-color: rgba(247,37,133,0.3); background: rgba(247,37,133,0.06); }
    #modeBadge.mode-erase::before { background: var(--magenta); box-shadow: 0 0 8px var(--magenta); }
    #modeBadge.mode-pan   { color: #aa88ff; border-color: rgba(170,136,255,0.3); background: rgba(170,136,255,0.06); }
    #modeBadge.mode-pan::before { background: #aa88ff; box-shadow: 0 0 8px #aa88ff; }

    /* ‚îÄ‚îÄ‚îÄ GESTURE LEGEND (right) ‚îÄ‚îÄ‚îÄ */
    #legend {
      position: fixed; top: 20px; right: 24px;
      z-index: 20; pointer-events: none;
      background: rgba(5,5,10,0.82);
      border: 1px solid var(--border);
      border-right: 2px solid var(--cyan);
      backdrop-filter: blur(12px);
      padding: 14px 18px;
      border-radius: 6px;
      min-width: 210px;
    }
    .legend-head {
      font-family: var(--display);
      font-size: 11px; font-weight: 700;
      letter-spacing: 3px; text-transform: uppercase;
      color: var(--cyan); margin-bottom: 10px;
    }
    .legend-row {
      display: flex; align-items: center; gap: 10px;
      padding: 4px 0;
      border-bottom: 1px solid rgba(255,255,255,0.04);
    }
    .legend-row:last-child { border: none; }
    .legend-emo { font-size: 15px; width: 22px; text-align: center; }
    .legend-text { font-family: var(--mono); font-size: 9px; letter-spacing: 0.8px; color: var(--muted); line-height: 1.4; }
    .legend-text strong { color: var(--text); display: block; margin-bottom: 1px; }

    /* ‚îÄ‚îÄ‚îÄ GESTURE FLASH ‚îÄ‚îÄ‚îÄ */
    #gFlash {
      position: fixed; top: 50%; left: 50%; z-index: 30;
      transform: translate(-50%, -50%) scale(0.8);
      font-family: var(--display); font-size: 72px; font-weight: 800;
      letter-spacing: 4px; text-align: center;
      opacity: 0; pointer-events: none;
      text-shadow: 0 0 80px rgba(247,37,133,0.6);
      color: white;
      transition: opacity 0.12s, transform 0.12s;
    }
    #gFlash.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }

    /* ‚îÄ‚îÄ‚îÄ STATUS BAR ‚îÄ‚îÄ‚îÄ */
    #statusBar {
      position: fixed; bottom: 20px; left: 20px;
      z-index: 20; pointer-events: none;
      display: flex; align-items: center; gap: 10px;
      font-family: var(--mono); font-size: 9px;
      letter-spacing: 2px; text-transform: uppercase; color: var(--muted);
    }
    .s-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--muted); }
    .s-dot.on { background: var(--cyan); box-shadow: 0 0 10px var(--cyan); animation: livepulse 2s infinite; }

    /* ‚îÄ‚îÄ‚îÄ LOADING ‚îÄ‚îÄ‚îÄ */
    #loading {
      position: fixed; inset: 0; z-index: 100;
      background: var(--bg);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center; gap: 24px;
    }
    .ld-title {
      font-family: var(--display); font-size: 58px; font-weight: 800;
      letter-spacing: 0.15em; color: var(--cyan);
      text-shadow: 0 0 60px rgba(0,245,212,0.4);
    }
    .ld-sub { font-family: var(--mono); font-size: 10px; letter-spacing: 4px; color: var(--muted); }
    .ld-track { width: 280px; height: 2px; background: var(--border); border-radius: 1px; overflow: hidden; }
    .ld-fill { height: 100%; background: linear-gradient(90deg, var(--cyan), var(--purple)); width: 0; transition: width 0.4s; box-shadow: 0 0 12px var(--cyan); }
    .ld-msg { font-family: var(--mono); font-size: 9px; letter-spacing: 2px; color: var(--muted); min-height: 14px; }

    /* ‚îÄ‚îÄ‚îÄ TOOLBAR ‚îÄ‚îÄ‚îÄ */
    #toolbar {
      position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
      z-index: 20;
      display: flex; gap: 8px; align-items: center;
      background: rgba(5,5,10,0.85);
      border: 1px solid var(--border);
      backdrop-filter: blur(16px);
      padding: 10px 16px;
      border-radius: 50px;
      box-shadow: 0 4px 30px rgba(0,0,0,0.5);
    }
    .tb-btn {
      display: flex; align-items: center; justify-content: center;
      gap: 6px; padding: 7px 14px;
      border-radius: 30px; border: 1px solid var(--border);
      background: transparent; color: var(--muted);
      font-family: var(--mono); font-size: 9px; letter-spacing: 1.5px;
      text-transform: uppercase; cursor: pointer;
      transition: all 0.2s;
    }
    .tb-btn:hover { background: rgba(255,255,255,0.06); color: var(--text); border-color: rgba(255,255,255,0.15); }
    .tb-btn.active { background: rgba(0,245,212,0.1); color: var(--cyan); border-color: rgba(0,245,212,0.3); }
    .tb-btn.danger:hover { background: rgba(247,37,133,0.1); color: var(--magenta); border-color: rgba(247,37,133,0.3); }
    .tb-sep { width: 1px; height: 24px; background: var(--border); }
    .tb-dot { width: 8px; height: 8px; border-radius: 50%; }
  </style>
</head>
<body>

<!-- Loading -->
<div id="loading">
  <div class="ld-title">GESTUREBOARD</div>
  <div class="ld-sub">Real-Time Hand-Controlled Canvas</div>
  <div class="ld-track"><div class="ld-fill" id="ldFill"></div></div>
  <div class="ld-msg" id="ldMsg">Initializing‚Ä¶</div>
</div>

<!-- Gesture Flash -->
<div id="gFlash"></div>

<!-- Main Canvas -->
<canvas id="mainCanvas"></canvas>

<!-- HUD Left -->
<div id="hudLeft">
  <div class="hud-brand">GESTURE<span>BOARD</span></div>
  <div id="modeBadge">PASSIVE</div>
  <div class="hud-card">
    <div class="hud-row">
      <span class="hud-k">GESTURE</span>
      <span class="hud-v c-cyan" id="hGest">‚Äî</span>
    </div>
    <div class="hud-row">
      <span class="hud-k">POLYGONS</span>
      <span class="hud-v" id="hPoly">0</span>
    </div>
    <div class="hud-row">
      <span class="hud-k">ZOOM</span>
      <span class="hud-v c-purple" id="hZoom">100%</span>
    </div>
    <div class="hud-row">
      <span class="hud-k">FPS</span>
      <span class="hud-v c-cyan" id="hFps">‚Äî</span>
    </div>
    <div class="hud-row">
      <span class="hud-k">HANDS</span>
      <span class="hud-v" id="hHands">0</span>
    </div>
    <div class="hud-row">
      <span class="hud-k">CONF.</span>
      <span class="hud-v c-yellow" id="hConf">‚Äî</span>
    </div>
  </div>
</div>

<!-- Gesture Legend -->
<div id="legend">
  <div class="legend-head">Gestures</div>
  <div class="legend-row">
    <span class="legend-emo">‚òùÔ∏è</span>
    <span class="legend-text"><strong>POINT</strong>Draw polygon vertices</span>
  </div>
  <div class="legend-row">
    <span class="legend-emo">‚úåÔ∏è</span>
    <span class="legend-text"><strong>PEACE</strong>Finalize polygon</span>
  </div>
  <div class="legend-row">
    <span class="legend-emo">üñêÔ∏è</span>
    <span class="legend-text"><strong>OPEN HAND</strong>Pan canvas</span>
  </div>
  <div class="legend-row">
    <span class="legend-emo">ü§å</span>
    <span class="legend-text"><strong>PINCH (2H)</strong>Zoom in/out</span>
  </div>
  <div class="legend-row">
    <span class="legend-emo">‚úä</span>
    <span class="legend-text"><strong>FIST</strong>Erase all</span>
  </div>
  <div class="legend-row">
    <span class="legend-emo">ü§ò</span>
    <span class="legend-text"><strong>ROCK-ON</strong>Undo last</span>
  </div>
</div>

<!-- Status bar -->
<div id="statusBar">
  <div class="s-dot" id="sDot"></div>
  <span id="sText">INITIALIZING</span>
</div>

<!-- Camera Panel -->
<div id="camWrap">
  <video id="webcam" autoplay muted playsinline></video>
  <canvas id="camCanvas"></canvas>
  <div class="cam-badge">LIVE</div>
</div>

<!-- Toolbar -->
<div id="toolbar">
  <button class="tb-btn danger" onclick="App.eraseAll()">‚úï CLEAR</button>
  <div class="tb-sep"></div>
  <button class="tb-btn" onclick="App.undo()">‚Ü© UNDO</button>
  <div class="tb-sep"></div>
  <button class="tb-btn" onclick="App.resetView()">‚äû RESET VIEW</button>
  <div class="tb-sep"></div>
  <button class="tb-btn" onclick="toggleColorCycle()">
    <div class="tb-dot" id="colorDot" style="background:var(--cyan)"></div>
    COLOR
  </button>
</div>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
  'use strict';
  /*
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   *  GESTUREBOARD ‚Äî Modular Architecture
   *  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   *  Modules:
   *   Config         ‚Äî tuneable constants
   *   PointerSmoother‚Äî adaptive EMA jitter reduction
   *   TransformMgr   ‚Äî zoom/pan matrix & coordinate mapping
   *   DrawingMgr     ‚Äî polygon state, undo/redo, rendering
   *   GestureMgr     ‚Äî MediaPipe Hands + gesture classifier
   *   HudMgr         ‚Äî all DOM HUD updates
   *   App            ‚Äî orchestrates all modules, animation loop
   * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   */

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  //  CONFIG ‚Äî single source of truth
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const Config = Object.freeze({
    // Pointer smoothing (0 = lock, 1 = raw)
    SMOOTH_ALPHA:       0.22,
    SMOOTH_ALPHA_FAST:  0.5,  // used in pan/zoom for snappier feel
    // Gesture confirmation: must hold N frames to confirm
    HOLD_FRAMES: 10,
    // Polygon
    MIN_VERTS:   3,
    MIN_MOVE:    4,   // world units before new vertex recorded
    // Zoom limits
    ZOOM_MIN: 0.15,
    ZOOM_MAX: 12,
    // MediaPipe confidence
    DETECT_CONF:  0.72,
    TRACK_CONF:   0.70,
    // Pinch detection distance threshold
    PINCH_DIST:   0.065,
  });

  // Palette cycle for polygon colors
  const PALETTES = [
    { stroke: '#00f5d4', fill: 'rgba(0,245,212,0.06)' },
    { stroke: '#ffd60a', fill: 'rgba(255,214,10,0.06)' },
    { stroke: '#f72585', fill: 'rgba(247,37,133,0.06)' },
    { stroke: '#7b2fff', fill: 'rgba(123,47,255,0.06)' },
    { stroke: '#ff6b35', fill: 'rgba(255,107,53,0.06)' },
  ];
  let paletteIdx = 0;
  function currentPalette() { return PALETTES[paletteIdx]; }
  function toggleColorCycle() {
    paletteIdx = (paletteIdx + 1) % PALETTES.length;
    document.getElementById('colorDot').style.background = PALETTES[paletteIdx].stroke;
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  //  POINTER SMOOTHER
  //  Adaptive EMA: slows smoothing when
  //  hand velocity is high (fast move=
  //  responsive, slow move=smooth)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  class PointerSmoother {
    constructor(alpha = Config.SMOOTH_ALPHA) {
      this._alpha = alpha;
      this._x = null;
      this._y = null;
      this._velX = 0;
      this._velY = 0;
    }

    /**
     * Feed raw position, returns smoothed {x,y}.
     * Uses velocity-adaptive alpha: faster movement
     * gets higher alpha (less smoothing) for responsiveness.
     */
    update(nx, ny) {
      if (this._x === null) {
        this._x = nx; this._y = ny;
        return { x: nx, y: ny };
      }
      const dx = nx - this._x, dy = ny - this._y;
      const vel = Math.hypot(dx, dy);
      // Adapt: velocity > 60px ‚Üí use fast alpha, blend linearly
      const t = Math.min(1, vel / 60);
      const alpha = this._alpha + t * (Config.SMOOTH_ALPHA_FAST - this._alpha);

      this._x += alpha * dx;
      this._y += alpha * dy;
      this._velX = dx;
      this._velY = dy;
      return { x: this._x, y: this._y };
    }

    reset() { this._x = null; this._y = null; }
    get pos() { return this._x === null ? null : { x: this._x, y: this._y }; }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  //  TRANSFORM MANAGER
  //  Wraps scale + translate matrix;
  //  supports pinch-zoom and pan ops.
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  class TransformMgr {
    constructor() {
      this.scale = 1;
      this.tx = 0;
      this.ty = 0;
      this._pinch0 = null; // snapshot at pinch start
      this._pan0   = null; // snapshot at pan start
    }

    /** Apply current transform to canvas 2D context */
    apply(ctx) {
      ctx.setTransform(this.scale, 0, 0, this.scale, this.tx, this.ty);
    }

    /** Screen ‚Üí World */
    toWorld(sx, sy) {
      return { x: (sx - this.tx) / this.scale, y: (sy - this.ty) / this.scale };
    }

    /** World ‚Üí Screen */
    toScreen(wx, wy) {
      return { x: wx * this.scale + this.tx, y: wy * this.scale + this.ty };
    }

    // ‚îÄ‚îÄ PINCH ZOOM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    startPinch(p1, p2) {
      this._pinch0 = {
        cx: (p1.x + p2.x) / 2,
        cy: (p1.y + p2.y) / 2,
        d: Math.hypot(p2.x - p1.x, p2.y - p1.y),
        scale: this.scale,
        tx: this.tx, ty: this.ty,
      };
    }

    updatePinch(p1, p2) {
      if (!this._pinch0) return;
      const s0 = this._pinch0;
      const cx = (p1.x + p2.x) / 2;
      const cy = (p1.y + p2.y) / 2;
      const d  = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      const newScale = Math.max(Config.ZOOM_MIN, Math.min(Config.ZOOM_MAX, s0.scale * (d / s0.d)));
      // Zoom around pinch midpoint
      const ratio = newScale / s0.scale;
      this.tx = cx - (s0.cx - s0.tx) * ratio;
      this.ty = cy - (s0.cy - s0.ty) * ratio;
      this.scale = newScale;
    }

    endPinch() { this._pinch0 = null; }

    // ‚îÄ‚îÄ PAN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    startPan(cx, cy) {
      this._pan0 = { cx, cy, tx: this.tx, ty: this.ty };
    }

    updatePan(cx, cy) {
      if (!this._pan0) return;
      this.tx = this._pan0.tx + (cx - this._pan0.cx);
      this.ty = this._pan0.ty + (cy - this._pan0.cy);
    }

    endPan() { this._pan0 = null; }

    reset() {
      this.scale = 1; this.tx = 0; this.ty = 0;
      this._pinch0 = null; this._pan0 = null;
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  //  DRAWING MANAGER
  //  Manages polygon list, draft state,
  //  undo stack, and all canvas drawing.
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  class DrawingMgr {
    constructor(canvas) {
      this.canvas    = canvas;
      this.ctx       = canvas.getContext('2d', { alpha: false });
      this.transform = new TransformMgr();

      this.polygons  = []; // [{pts:[{x,y}‚Ä¶], stroke, fill}]
      this.draft     = []; // in-progress polygon points
      this.inDraft   = false;
      this.undoStack = []; // copies of polygons array

      this._grid = null;
      this._resize();
      window.addEventListener('resize', () => this._resize());
    }

    _resize() {
      this.canvas.width  = window.innerWidth;
      this.canvas.height = window.innerHeight;
      this._buildGrid();
    }

    // Pre-render grid to offscreen canvas for perf
    _buildGrid() {
      const gc  = document.createElement('canvas');
      gc.width  = window.innerWidth;
      gc.height = window.innerHeight;
      const gx  = gc.getContext('2d');
      const step = 52;
      gx.strokeStyle = 'rgba(25,25,50,0.7)';
      gx.lineWidth   = 0.5;
      for (let x = 0.5; x < gc.width; x += step) {
        gx.beginPath(); gx.moveTo(x, 0); gx.lineTo(x, gc.height); gx.stroke();
      }
      for (let y = 0.5; y < gc.height; y += step) {
        gx.beginPath(); gx.moveTo(0, y); gx.lineTo(gc.width, y); gx.stroke();
      }
      // Dot at each intersection
      gx.fillStyle = 'rgba(40,40,80,0.6)';
      for (let x = step; x < gc.width; x += step) {
        for (let y = step; y < gc.height; y += step) {
          gx.beginPath(); gx.arc(x, y, 0.8, 0, Math.PI*2); gx.fill();
        }
      }
      this._grid = gc;
    }

    addDraftPt(wx, wy) {
      if (!this.inDraft) { this.inDraft = true; this.draft = []; }
      const last = this.draft[this.draft.length - 1];
      if (!last || Math.hypot(wx - last.x, wy - last.y) > Config.MIN_MOVE) {
        this.draft.push({ x: wx, y: wy });
      }
    }

    finalizeDraft() {
      if (this.draft.length >= Config.MIN_VERTS) {
        this._saveUndo();
        const p = currentPalette();
        this.polygons.push({ pts: [...this.draft], stroke: p.stroke, fill: p.fill });
      }
      this.draft = []; this.inDraft = false;
    }

    cancelDraft() { this.draft = []; this.inDraft = false; }

    undo() {
      if (this.undoStack.length) this.polygons = this.undoStack.pop();
      this.cancelDraft();
    }

    eraseAll() {
      this._saveUndo();
      this.polygons = [];
      this.cancelDraft();
    }

    _saveUndo() { this.undoStack.push(this.polygons.map(p => ({ ...p, pts: [...p.pts] }))); }

    /**
     * Master render ‚Äî called every rAF.
     * @param {Object|null} cursorSS - screen-space cursor pos
     * @param {boolean} drawing - whether in draw mode
     */
    render(cursorSS, drawing) {
      const ctx  = this.ctx;
      const W    = this.canvas.width;
      const H    = this.canvas.height;

      // 1. Background
      ctx.resetTransform();
      ctx.fillStyle = '#05050a';
      ctx.fillRect(0, 0, W, H);

      // 2. Grid (screen space ‚Äî stays fixed regardless of zoom)
      if (this._grid) ctx.drawImage(this._grid, 0, 0);

      // 3. World transform for polygon layer
      this.transform.apply(ctx);

      // 4. Finalized polygons
      for (const poly of this.polygons) {
        this._renderPoly(ctx, poly.pts, poly.stroke, poly.fill, false);
      }

      // 5. Draft polygon
      if (this.draft.length > 0) {
        const pal = currentPalette();
        this._renderPoly(ctx, this.draft, pal.stroke, pal.fill, true);

        // Dashed preview line: last draft pt ‚Üí cursor
        if (cursorSS && this.draft.length > 0) {
          const cw   = this.transform.toWorld(cursorSS.x, cursorSS.y);
          const last = this.draft[this.draft.length - 1];
          const lw   = 1 / this.transform.scale;
          ctx.beginPath();
          ctx.moveTo(last.x, last.y);
          ctx.lineTo(cw.x, cw.y);
          ctx.strokeStyle = pal.stroke + '55';
          ctx.lineWidth   = lw;
          ctx.setLineDash([5 / this.transform.scale, 5 / this.transform.scale]);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }

      // 6. Screen-space: cursor
      ctx.resetTransform();
      if (cursorSS) this._renderCursor(ctx, cursorSS.x, cursorSS.y, drawing);
    }

    _renderPoly(ctx, pts, stroke, fill, open) {
      if (pts.length < 2) return;
      const s = this.transform.scale;
      const lw = 1.5 / s;

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      if (!open) ctx.closePath();

      ctx.fillStyle = fill;
      ctx.fill();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = lw;
      ctx.lineJoin = ctx.lineCap = 'round';
      ctx.stroke();

      // Vertices
      const r = 2.8 / s;
      ctx.fillStyle = stroke;
      for (const p of pts) {
        ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI * 2); ctx.fill();
      }

      // Closing indicator on draft
      if (open && pts.length >= Config.MIN_VERTS) {
        const r2 = 6 / s;
        ctx.beginPath(); ctx.arc(pts[0].x, pts[0].y, r2, 0, Math.PI*2);
        ctx.strokeStyle = stroke; ctx.lineWidth = 1 / s;
        ctx.setLineDash([3/s, 3/s]);
        ctx.stroke(); ctx.setLineDash([]);
      }
    }

    _renderCursor(ctx, sx, sy, drawing) {
      const color = drawing ? '#ffd60a' : '#00f5d4';
      const glow  = drawing ? 'rgba(255,214,10,0.3)' : 'rgba(0,245,212,0.3)';
      const R = 11;

      ctx.save();
      ctx.translate(sx, sy);

      // Glow ring
      const grad = ctx.createRadialGradient(0, 0, R-1, 0, 0, R+8);
      grad.addColorStop(0, glow); grad.addColorStop(1, 'transparent');
      ctx.beginPath(); ctx.arc(0, 0, R+8, 0, Math.PI*2);
      ctx.fillStyle = grad; ctx.fill();

      // Main ring
      ctx.beginPath(); ctx.arc(0, 0, R, 0, Math.PI*2);
      ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.globalAlpha = 0.9;
      ctx.stroke();

      // Cross hairs
      ctx.lineWidth = 1; ctx.globalAlpha = 0.55;
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(-R*1.8, 0); ctx.lineTo(-R*0.45, 0);
      ctx.moveTo(R*0.45, 0);  ctx.lineTo(R*1.8, 0);
      ctx.moveTo(0, -R*1.8); ctx.lineTo(0, -R*0.45);
      ctx.moveTo(0, R*0.45);  ctx.lineTo(0, R*1.8);
      ctx.stroke();

      // Center dot
      ctx.globalAlpha = 1;
      ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, Math.PI*2);
      ctx.fillStyle = color; ctx.fill();

      ctx.restore();
    }

    // Brief red flash when erasing
    flashErase() {
      const ctx = this.ctx;
      ctx.resetTransform();
      ctx.fillStyle = 'rgba(247,37,133,0.14)';
      ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    seedDemoPolygons() {
      const W = window.innerWidth, H = window.innerHeight;

      // Hexagon
      const c1x = W * 0.32, c1y = H * 0.42, r1 = 90;
      const hex  = [];
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 3) * i - Math.PI / 6;
        hex.push({ x: c1x + r1 * Math.cos(a), y: c1y + r1 * Math.sin(a) });
      }
      this.polygons.push({ pts: hex, stroke: '#00f5d4', fill: 'rgba(0,245,212,0.06)' });

      // Diamond
      const c2x = W * 0.58, c2y = H * 0.40;
      this.polygons.push({
        pts: [{ x: c2x, y: c2y - 70 }, { x: c2x + 52, y: c2y }, { x: c2x, y: c2y + 70 }, { x: c2x - 52, y: c2y }],
        stroke: '#7b2fff', fill: 'rgba(123,47,255,0.06)'
      });

      // Triangle
      const c3x = W * 0.45, c3y = H * 0.65, r3 = 55;
      const tri = [];
      for (let i = 0; i < 3; i++) {
        const a = (Math.PI * 2 / 3) * i - Math.PI / 2;
        tri.push({ x: c3x + r3 * Math.cos(a), y: c3y + r3 * Math.sin(a) });
      }
      this.polygons.push({ pts: tri, stroke: '#ffd60a', fill: 'rgba(255,214,10,0.06)' });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  //  GESTURE MANAGER
  //  Wraps MediaPipe Hands.
  //  Classifies per-frame gestures and
  //  debounces them over HOLD_FRAMES
  //  before firing "confirmed" gesture.
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  class GestureMgr {
    constructor(videoEl, overlayCanvas, onResults) {
      this.videoEl   = videoEl;
      this.overlay   = overlayCanvas;
      this.octx      = overlayCanvas.getContext('2d');
      this.onResults = onResults;

      // Per-hand state (max 2 hands)
      this._smoothers = Array.from({ length: 2 }, () => new PointerSmoother());
      this._lastG     = ['none', 'none'];
      this._holdCnt   = [0, 0];
      this._confirmed = ['none', 'none'];

      this.hands  = null;
      this.camera = null;
    }

    async init(onProgress) {
      this.hands = new Hands({
        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`,
      });

      this.hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: Config.DETECT_CONF,
        minTrackingConfidence:  Config.TRACK_CONF,
      });

      this.hands.onResults(r => this._process(r));

      onProgress('Loading hand detection model‚Ä¶', 25);
      await this.hands.initialize();
      onProgress('Starting webcam‚Ä¶', 65);

      this.camera = new Camera(this.videoEl, {
        onFrame: async () => {
          this.overlay.width  = this.videoEl.videoWidth  || 640;
          this.overlay.height = this.videoEl.videoHeight || 480;
          await this.hands.send({ image: this.videoEl });
        },
        width: 640, height: 480,
      });

      await this.camera.start();
      onProgress('Ready!', 100);
    }

    /**
     * Classify a single hand's 21 landmarks into one of:
     * fist | point | peace | pinch | rockon | open | unknown
     *
     * Uses relative tip-vs-PIP height for fingers 1-4,
     * and thumb-x comparison for thumb.
     * Falls back to tip-distance for pinch when not obvious.
     */
    _classify(lm) {
      const tipIds = [4, 8, 12, 16, 20]; // thumb..pinky tips
      const pipIds = [2, 6, 10, 14, 18]; // their reference joints

      const up = tipIds.map((tip, i) => {
        if (i === 0) return lm[tip].x < lm[pipIds[i]].x; // thumb: horizontal
        return lm[tip].y < lm[pipIds[i]].y;               // others: vertical
      });

      const [thumb, index, middle, ring, pinky] = up;

      if (!thumb && !index && !middle && !ring && !pinky)  return 'fist';
      if (!thumb && index && !middle && !ring && !pinky)   return 'point';
      if (!thumb && index && middle  && !ring && !pinky)   return 'peace';
      if (!thumb && index && !middle && !ring && pinky)    return 'rockon';
      if (thumb && index && middle && ring && pinky)       return 'open';

      // Pinch: thumb & index close together
      const pd = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
      if (pd < Config.PINCH_DIST) return 'pinch';

      return 'unknown';
    }

    _process(results) {
      const ctx = this.octx;
      const W   = this.overlay.width;
      const H   = this.overlay.height;
      ctx.clearRect(0, 0, W, H);

      const landmarks = results.multiHandLandmarks || [];
      const count     = landmarks.length;

      const handData = landmarks.map((lm, i) => {
        // Draw skeleton on camera overlay
        drawConnectors(ctx, lm, HAND_CONNECTIONS, { color: 'rgba(0,245,212,0.3)', lineWidth: 1.2 });
        drawLandmarks(ctx, lm, { color: 'rgba(0,245,212,0.75)', lineWidth: 1, radius: 2.5 });

        // Index fingertip ‚Üí screen coordinates (mirror because video is flipped in CSS)
        const tip = lm[8];
        const raw = {
          x: (1 - tip.x) * window.innerWidth,
          y: tip.y * window.innerHeight,
        };
        const smoothed = this._smoothers[i].update(raw.x, raw.y);
        const gesture  = this._classify(lm);

        // Debounce: confirm after HOLD_FRAMES consecutive matching frames
        if (gesture === this._lastG[i]) {
          if (this._holdCnt[i] < Config.HOLD_FRAMES) this._holdCnt[i]++;
        } else {
          this._lastG[i]  = gesture;
          this._holdCnt[i] = 0;
        }
        if (this._holdCnt[i] >= Config.HOLD_FRAMES) {
          this._confirmed[i] = gesture;
        }

        // Wrist-center for two-hand ops
        const wrist = { x: (1 - lm[0].x) * window.innerWidth, y: lm[0].y * window.innerHeight };

        return { smoothed, raw, gesture, confirmed: this._confirmed[i], lm, wrist };
      });

      // Reset state for absent hands
      for (let i = count; i < 2; i++) {
        this._smoothers[i].reset();
        this._lastG[i]     = 'none';
        this._holdCnt[i]   = 0;
        this._confirmed[i] = 'none';
      }

      // Confidence display: avg hold count of active hands
      const avgConf = count === 0 ? 0
              : this._holdCnt.slice(0, count).reduce((a, b) => a + b, 0) / count;

      this.onResults({ hands: handData, count, confidence: avgConf / Config.HOLD_FRAMES });
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  //  HUD MANAGER
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  class HudMgr {
    constructor() {
      this._badge  = document.getElementById('modeBadge');
      this._gest   = document.getElementById('hGest');
      this._poly   = document.getElementById('hPoly');
      this._zoom   = document.getElementById('hZoom');
      this._fps    = document.getElementById('hFps');
      this._hands  = document.getElementById('hHands');
      this._conf   = document.getElementById('hConf');
      this._flash  = document.getElementById('gFlash');
      this._sdot   = document.getElementById('sDot');
      this._stext  = document.getElementById('sText');
      this._flashTimer = null;
      this._lastFlash  = '';
    }

    update({ mode, gesture, polyCount, zoom, fps, hands, confidence }) {
      // Mode badge
      const badge = this._badge;
      badge.textContent = mode;
      badge.className   = '';
      if (mode === 'DRAWING') badge.className = 'mode-draw';
      else if (mode === 'ERASING') badge.className = 'mode-erase';
      else if (mode === 'PAN' || mode === 'ZOOM') badge.className = 'mode-pan';

      this._gest.textContent  = gesture;
      this._poly.textContent  = polyCount;
      this._zoom.textContent  = Math.round(zoom * 100) + '%';
      this._fps.textContent   = fps;
      this._hands.textContent = hands;
      this._conf.textContent  = Math.round(confidence * 100) + '%';
    }

    flashGesture(label) {
      if (this._lastFlash === label) return;
      this._lastFlash = label;
      clearTimeout(this._flashTimer);
      this._flash.textContent = label;
      this._flash.classList.add('show');
      this._flashTimer = setTimeout(() => {
        this._flash.classList.remove('show');
        this._lastFlash = '';
      }, 900);
    }

    setStatus(text, ready = false) {
      this._stext.textContent = text;
      this._sdot.className    = 's-dot' + (ready ? ' on' : '');
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  //  APP ‚Äî Main Orchestrator
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const App = (() => {
    const drawing = new DrawingMgr(document.getElementById('mainCanvas'));
    const hud     = new HudMgr();
    let   gesture = null; // GestureMgr, initialized async

    // State
    let mode           = 'passive'; // passive | drawing | panning | zooming | erasing
    let lastHandData   = { hands: [], count: 0, confidence: 0 };
    let cursorSS       = null; // screen-space cursor position
    let pinchActive    = false;
    let panActive      = false;
    let lastEraseFired = false;
    let lastRockFired  = false;

    // FPS tracking
    let fps = 0, fpsFrames = 0, fpsLast = performance.now();

    // Seed demo polygons
    drawing.seedDemoPolygons();

    // ‚îÄ‚îÄ Main animation loop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function loop(ts) {
      fpsFrames++;
      const elapsed = ts - fpsLast;
      if (elapsed >= 500) {
        fps = Math.round(fpsFrames / elapsed * 1000);
        fpsFrames = 0; fpsLast = ts;
      }

      processGestures(lastHandData);
      drawing.render(cursorSS, mode === 'drawing');

      hud.update({
        mode:       modeLabel(),
        gesture:    gestureLabel(),
        polyCount:  drawing.polygons.length,
        zoom:       drawing.transform.scale,
        fps,
        hands:      lastHandData.count,
        confidence: lastHandData.confidence || 0,
      });

      requestAnimationFrame(loop);
    }

    function modeLabel() {
      const m = { passive: 'PASSIVE', drawing: 'DRAWING', panning: 'PAN', zooming: 'ZOOM', erasing: 'ERASING' };
      return m[mode] || 'PASSIVE';
    }

    function gestureLabel() {
      const { hands } = lastHandData;
      if (!hands.length) return '‚Äî';
      return hands.map(h => h.gesture.toUpperCase()).join(' + ');
    }

    // ‚îÄ‚îÄ Gesture processor (called every frame) ‚îÄ‚îÄ
    function processGestures({ hands, count }) {
      const tr = drawing.transform;

      // Update cursor from first hand's index fingertip
      cursorSS = count > 0 ? { ...hands[0].smoothed } : null;

      // ‚îÄ‚îÄ TWO-HAND: Zoom (both pinch) or Pan (both open) ‚îÄ‚îÄ
      if (count === 2) {
        const g0 = hands[0].gesture, g1 = hands[1].gesture;
        const isPinch = (g) => g === 'pinch' || g === 'open';
        const isOpen  = (g) => g === 'open';

        if (isPinch(g0) && isPinch(g1)) {
          const p1 = hands[0].smoothed, p2 = hands[1].smoothed;
          if (!pinchActive) { tr.startPinch(p1, p2); pinchActive = true; }
          else tr.updatePinch(p1, p2);
          mode = 'zooming';
          drawing.cancelDraft();
          panActive = false;
          hud.flashGesture('‚äï ZOOM');
          return;
        } else {
          if (pinchActive) { tr.endPinch(); pinchActive = false; }
        }

        if (isOpen(g0) && isOpen(g1)) {
          const cx = (hands[0].smoothed.x + hands[1].smoothed.x) / 2;
          const cy = (hands[0].smoothed.y + hands[1].smoothed.y) / 2;
          if (!panActive) { tr.startPan(cx, cy); panActive = true; }
          else tr.updatePan(cx, cy);
          mode = 'panning';
          drawing.cancelDraft();
          return;
        } else {
          if (panActive) { tr.endPan(); panActive = false; }
        }
      } else {
        if (pinchActive) { tr.endPinch(); pinchActive = false; }
        if (panActive)   { tr.endPan();   panActive   = false; }
      }

      // ‚îÄ‚îÄ NO HANDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (count === 0) {
        if (mode === 'drawing') drawing.finalizeDraft();
        mode = 'passive';
        return;
      }

      // ‚îÄ‚îÄ SINGLE HAND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const h  = hands[0];
      const g  = h.gesture;
      const gc = h.confirmed;
      const sp = h.smoothed;

      // ERASE ‚Äî fist (debounced with confirmed)
      if (gc === 'fist') {
        if (!lastEraseFired) {
          lastEraseFired = true;
          drawing.eraseAll();
          drawing.flashErase();
          mode = 'erasing';
          hud.flashGesture('‚úä ERASE');
        }
        return;
      } else { lastEraseFired = false; }

      // UNDO ‚Äî rock-on
      if (gc === 'rockon') {
        if (!lastRockFired) {
          lastRockFired = true;
          drawing.undo();
          mode = 'passive';
          hud.flashGesture('ü§ò UNDO');
        }
        return;
      } else { lastRockFired = false; }

      // FINALIZE ‚Äî peace
      if (g === 'peace') {
        if (mode === 'drawing' && drawing.draft.length >= 3) {
          drawing.finalizeDraft();
          hud.flashGesture('‚úåÔ∏è DONE');
        }
        mode = 'passive';
        return;
      }

      // DRAW ‚Äî point
      if (g === 'point') {
        const w = tr.toWorld(sp.x, sp.y);
        drawing.addDraftPt(w.x, w.y);
        mode = 'drawing';
        return;
      }

      // PAN ‚Äî open hand (single hand)
      if (g === 'open') {
        if (mode === 'drawing') {
          drawing.finalizeDraft();
          hud.flashGesture('üñêÔ∏è SAVED');
        }
        if (!panActive) { tr.startPan(sp.x, sp.y); panActive = true; }
        else tr.updatePan(sp.x, sp.y);
        mode = 'panning';
        return;
      }

      // Default: if we were drawing, auto-finalize
      if (mode === 'drawing') {
        drawing.finalizeDraft();
        hud.flashGesture('‚úÖ SAVED');
      }
      mode = 'passive';
    }

    // ‚îÄ‚îÄ Async startup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    async function start() {
      const fill = document.getElementById('ldFill');
      const msg  = document.getElementById('ldMsg');

      const onProgress = (text, pct) => {
        fill.style.width  = pct + '%';
        msg.textContent   = text;
      };

      onProgress('Loading gesture model‚Ä¶', 10);

      gesture = new GestureMgr(
              document.getElementById('webcam'),
              document.getElementById('camCanvas'),
              data => { lastHandData = data; }
      );

      try {
        await gesture.init(onProgress);
        hud.setStatus('TRACKING ACTIVE', true);
      } catch (err) {
        console.error(err);
        hud.setStatus('CAMERA ERROR', false);
        msg.textContent = '‚ö† ' + err.message;
        return;
      }

      // Fade out loading screen
      const ld = document.getElementById('loading');
      ld.style.transition = 'opacity 0.65s ease';
      ld.style.opacity    = '0';
      setTimeout(() => { ld.style.display = 'none'; }, 750);

      requestAnimationFrame(loop);
    }

    // ‚îÄ‚îÄ Public API (used by toolbar buttons) ‚îÄ‚îÄ‚îÄ‚îÄ
    return {
      start,
      eraseAll() { drawing.eraseAll(); drawing.flashErase(); hud.flashGesture('‚úä ERASE'); },
      undo()     { drawing.undo(); hud.flashGesture('ü§ò UNDO'); },
      resetView(){ drawing.transform.reset(); },
    };
  })();

  // Kick off
  App.start().catch(console.error);
</script>
</body>
</html>